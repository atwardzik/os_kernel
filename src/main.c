#include "../include/drivers/gpio.h"
#include "drivers/keyboard.h"
#include "drivers/time.h"
#include "drivers/uart.h"
#include "drivers/vga.h"
#include "fs/file.h"
#include "fs/ramfs.h"
#include "kernel/memory.h"
#include "kernel/proc.h"
#include "kernel/resets.h"
#include "kernel/syscalls.h"
#include "klibc/kstdio.h"
#include "klibc/kstring.h"
#include "tty.h"

#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/errno.h>
#include <sys/unistd.h>
#include <sys/wait.h>

void proc1_terminate_signal_handler(int signum) {
        if (signum == SIGTERM) {
                printf("[SIGTERM DETECTED] I don't want to exit, but as you wish\n");
        }

        exit(-1);
}

void proc1(void) {
        signal(SIGTERM, proc1_terminate_signal_handler);

        while (1) {
                xor_pin(11);
                delay_ms(250);
        }
}

int proc2_main(void) {
        printf("\x1b[33;40m[!]Welcome from proc2\x1b[0m\n");

        char buffer[255];

        printf(" ~ ");
        fgets(buffer, 255, stdin);
        printf("Response: %s\n", buffer);

        return 0;
}

void PATER_ADAMVS_SIGINT(int signum) {
        printf("\x1b[91;40mTrying to exit the init process is a bloody bad idea.\x1b[0m\n");
}

static uint16_t raw_bytes_function[] __attribute__((aligned(4))) = {
        0xf04f, 0x0001, 0xf20f, 0x010c, 0xf04f, 0x020d, 0xdf04, 0xf04f, 0x0000,
        0xdf01, 0x6548, 0x6c6c, 0x206f, 0x6f57, 0x6c72, 0x2164, 0x0000, 0xbf00,
};

static uint16_t raw_ls[] __attribute__((aligned(4))) = {
        // 0xb580, 0xb08e, 0xaf00, 0x6078, 0x6039, 0x683b, 0x685b, 0xf44f, 0x1100, 0x4618, 0xdf05, 0x6378, 0xe012, 0xf107,
        // 0x030c, 0x3308, 0xb408, 0x4618, 0xf000, 0xf824, 0x4602, 0xf04f, 0x0001, 0xbc02, 0xdf04, 0xf04f, 0x0001, 0xf20f,
        // 0x014a, 0xf04f, 0x0201, 0xdf04, 0xf107, 0x030c, 0x4619, 0x6b78, 0xdf08, 0x4603, 0x2b00, 0xd1e4, 0x2300, 0x4618,
        // 0x3738, 0x46bd, 0xf04f, 0x0000, 0xe8bd, 0x4080, 0xdf01, 0xbf00, 0xf3af, 0x8000, 0xf3af, 0x8000, 0xf3af, 0x8000,
        // 0x2100, 0x6802, 0x2a00, 0xd002, 0x3101, 0x3001, 0xe7f9, 0x4608, 0x4770, 0x000a,

        // 0xe011, 0xdf01, 0x46c0, 0xb580, 0xb086, 0xaf00, 0x60f8, 0x60b9, 0x607a, 0xdf04, 0x1c03, 0x617b, 0x697b, 0x0018,
        // 0x46bd, 0xb006, 0xbc80, 0xbc02, 0x4708, 0xb580, 0xb082, 0xaf00, 0x4b07, 0x447b, 0x607b, 0x687b, 0x220d, 0x0019,
        // 0x2001, 0xf7ff, 0xffe4, 0x2300, 0x0018, 0x46bd, 0xb002, 0xbc80, 0xbc02, 0x4708, 0x001e, 0x0000, 0x6548, 0x6c6c,
        // 0x206f, 0x6f57, 0x6c72, 0x2164, 0x000a

        0xb580, 0xf5ad, 0x7d12, 0xaf00, 0x4be8, 0x447b, 0x4618, 0xf000, 0xfa9f, 0x1d3b, 0xf44f, 0x7280, 0x4619, 0x2000,
        0xf000, 0xfa1f, 0x4603, 0x2b00, 0xf340, 0x81be, 0x1d3b, 0x4ae1, 0x447a, 0x4611, 0x4618, 0xf000, 0xfa9f, 0x4602,
        0xf507, 0x7312, 0xf5a3, 0x7311, 0x2100, 0x5499, 0x1d3b, 0x4adb, 0x447a, 0x4611, 0x4618, 0xf000, 0xfafb, 0xf8c7,
        0x0244, 0x4bd8, 0x447b, 0x4619, 0xf8d7, 0x0244, 0xf000, 0xfb60, 0x4603, 0x2b00, 0xd009, 0x4bd4, 0x447b, 0x4619,
        0xf8d7, 0x0244, 0xf000, 0xfb56, 0x4603, 0x2b00, 0xd105, 0x4bd0, 0x447b, 0x4618, 0xf000, 0xfa64, 0xe18f, 0x4bce,
        0x447b, 0x4619, 0xf8d7, 0x0244, 0xf000, 0xfb46, 0x4603, 0x2b00, 0xd009, 0x4bca, 0x447b, 0x4619, 0xf8d7, 0x0244,
        0xf000, 0xfb3c, 0x4603, 0x2b00, 0xd154, 0x4bc6, 0x447b, 0x4619, 0x2000, 0xf000, 0xfac5, 0xf8c7, 0x0218, 0x2200,
        0xf44f, 0x3180, 0xf8d7, 0x0218, 0xf000, 0xf9d6, 0xf8c7, 0x0214, 0xf8d7, 0x3214, 0x2b00, 0xda05, 0x4bbc, 0x447b,
        0x4618, 0xf000, 0xfa35, 0xe78f, 0xf507, 0x7382, 0x2280, 0x4619, 0xf8d7, 0x0214, 0xf000, 0xf9b3, 0xf04f, 0x33ff,
        0xf8c7, 0x3210, 0xf04f, 0x33ff, 0xf8c7, 0x320c, 0x4bb2, 0x447b, 0x4618, 0xf000, 0xfa1f, 0xf507, 0x7301, 0x220a,
        0x4619, 0xf8d7, 0x020c, 0xf000, 0xfb34, 0xf507, 0x7301, 0x4618, 0xf000, 0xfa12, 0x4baa, 0x447b, 0x4618, 0xf000,
        0xfa0d, 0xf507, 0x7301, 0x220a, 0x4619, 0xf8d7, 0x0210, 0xf000, 0xfb22, 0xf507, 0x7301, 0x4618, 0xf000, 0xfa00,
        0x4ba2, 0x447b, 0x4618, 0xf000, 0xf9fb, 0xe126, 0x4ba0, 0x447b, 0x4619, 0xf8d7, 0x0244, 0xf000, 0xfadd, 0x4603,
        0x2b00, 0xd009, 0x4b9c, 0x447b, 0x4619, 0xf8d7, 0x0244, 0xf000, 0xfad3, 0x4603, 0x2b00, 0xd105, 0x4b98, 0x447b,
        0x4618, 0xf000, 0xf9e1, 0xe10c, 0x4b96, 0x447b, 0x4619, 0xf8d7, 0x0244, 0xf000, 0xfac3, 0x4603, 0x2b00, 0xd009,
        0x4b92, 0x447b, 0x4619, 0xf8d7, 0x0244, 0xf000, 0xfab9, 0x4603, 0x2b00, 0xd105, 0x4b8e, 0x447b, 0x4618, 0xf000,
        0xf9c7, 0xe0f2, 0x4b8c, 0x447b, 0x4619, 0xf8d7, 0x0244, 0xf000, 0xfaa9, 0x4603, 0x2b00, 0xd009, 0x4b88, 0x447b,
        0x4619, 0xf8d7, 0x0244, 0xf000, 0xfa9f, 0x4603, 0x2b00, 0xd141, 0x4b84, 0x447b, 0x4619, 0x2000, 0xf000, 0xfa28,
        0xf8c7, 0x0224, 0x4b81, 0x447b, 0x4619, 0x2000, 0xf000, 0xfa20, 0xf8c7, 0x0220, 0xf8d7, 0x3224, 0x2b00, 0xf000,
        0x80c9, 0xf8d7, 0x3220, 0x2b00, 0xd104, 0xf8d7, 0x0224, 0xf000, 0xf995, 0xe0c0, 0x2200, 0x2101, 0xf8d7, 0x0220,
        0xf000, 0xf924, 0xf8c7, 0x021c, 0xf8d7, 0x321c, 0x2b00, 0xda05, 0x4b71, 0x447b, 0x4618, 0xf000, 0xf983, 0xe0ae,
        0xf8d7, 0x0224, 0xf000, 0xf968, 0x4603, 0x3301, 0x461a, 0xf8d7, 0x1224, 0xf8d7, 0x021c, 0xf000, 0xf8ed, 0xf8d7,
        0x021c, 0xf000, 0xf916, 0xe09c, 0x4b66, 0x447b, 0x4619, 0xf8d7, 0x0244, 0xf000, 0xfa53, 0x4603, 0x2b00, 0xd14b,
        0x4b62, 0x447b, 0x4619, 0x2000, 0xf000, 0xf9dc, 0xf8c7, 0x0230, 0xf8d7, 0x3230, 0x2b00, 0xd002, 0xf8d7, 0x3230,
        0xe001, 0x4b5c, 0x447b, 0xf8c7, 0x322c, 0x2200, 0xf44f, 0x1100, 0xf8d7, 0x022c, 0xf000, 0xf8e2, 0xf8c7, 0x0228,
        0xf8d7, 0x3228, 0x2b00, 0xda1a, 0x4b54, 0x447b, 0x4618, 0xf000, 0xf941, 0xe69b, 0xf507, 0x7382, 0x4618, 0xf000,
        0xf93b, 0x4b50, 0x447b, 0x4618, 0xf000, 0xf936, 0xf507, 0x7382, 0x3308, 0x4618, 0xf000, 0xf930, 0x4b4b, 0x447b,
        0x4618, 0xf000, 0xf92b, 0xf507, 0x7382, 0x4619, 0xf8d7, 0x0228, 0xf000, 0xf8d6, 0x4603, 0x2b01, 0xd0e0, 0x2200,
        0x2100, 0xf8d7, 0x0228, 0xf000, 0xf8e8, 0xe675, 0x4b41, 0x447b, 0x4619, 0xf8d7, 0x0244, 0xf000, 0xf9fd, 0x4603,
        0x2b00, 0xd119, 0x4b3d, 0x447b, 0x4619, 0x2000, 0xf000, 0xf986, 0xf8c7, 0x0238, 0xf8d7, 0x0238, 0xf000, 0xf8c4,
        0xf8c7, 0x0234, 0xf8d7, 0x3234, 0xf1b3, 0x3fff, 0xf47f, 0xae58, 0x4b34, 0x447b, 0x4618, 0xf000, 0xf8f7, 0xe651,
        0x4b32, 0x447b, 0x4619, 0xf8d7, 0x0244, 0xf000, 0xf9d9, 0x4603, 0x2b00, 0xf47f, 0xae47, 0xf507, 0x7382, 0xf8c7,
        0x3240, 0x2140, 0xf8d7, 0x0240, 0xf000, 0xf8be, 0xf8c7, 0x023c, 0xf8d7, 0x023c, 0xf000, 0xf8dc, 0x4b26, 0x447b,
        0x4618, 0xf000, 0xf8d7, 0xe631, 0xbf00, 0xe62f, 0xbf00, 0xe62d, 0x081e, 0x0000, 0x0800, 0x0000, 0x07e8, 0x0000,
        0x07dc, 0x0000, 0x07d0, 0x0000, 0x07c0, 0x0000, 0x0a10, 0x0000, 0x0a00, 0x0000, 0x077c, 0x0000, 0x09c6, 0x0000,
        0x09b2, 0x0000, 0x09ba, 0x0000, 0x06da, 0x0000, 0x099e, 0x0000, 0x0992, 0x0000, 0x0982, 0x0000, 0x097a, 0x0000,
        0x096e, 0x0000, 0x095e, 0x0000, 0x0996, 0x0000, 0x098a, 0x0000, 0x097a, 0x0000, 0x096e, 0x0000, 0x092e, 0x0000,
        0x090e, 0x0000, 0x05aa, 0x0000, 0x08c8, 0x0000, 0x08be, 0x0000, 0x0554, 0x0000, 0x053a, 0x0000, 0x0876, 0x0000,
        0x04fe, 0x0000, 0x0816, 0x0000, 0x0832, 0x0000, 0x0492, 0x0000, 0xf7ff, 0xbde2, 0xdf01, 0xbf00, 0xb480, 0xb087,
        0xaf00, 0x60f8, 0x60b9, 0x607a, 0xdf04, 0x4603, 0x617b, 0x697b, 0x4618, 0x371c, 0x46bd, 0xbc80, 0x4770, 0xb480,
        0xb087, 0xaf00, 0x60f8, 0x60b9, 0x607a, 0xdf03, 0x4603, 0x617b, 0x697b, 0x4618, 0x371c, 0x46bd, 0xbc80, 0x4770,
        0xb480, 0xb087, 0xaf00, 0x60f8, 0x60b9, 0x607a, 0xdf05, 0x4603, 0x617b, 0x697b, 0x4618, 0x371c, 0x46bd, 0xbc80,
        0x4770, 0xb480, 0xb085, 0xaf00, 0x6078, 0xdf06, 0x4603, 0x60fb, 0x68fb, 0x4618, 0x3714, 0x46bd, 0xbc80, 0x4770,
        0xb480, 0xb085, 0xaf00, 0x6078, 0x6039, 0xdf08, 0x4603, 0x60fb, 0x68fb, 0x4618, 0x3714, 0x46bd, 0xbc80, 0x4770,
        0xb480, 0xb085, 0xaf00, 0x6078, 0xdf09, 0x4603, 0x60fb, 0x68fb, 0x4618, 0x3714, 0x46bd, 0xbc80, 0x4770, 0xb480,
        0xb087, 0xaf00, 0x60f8, 0x60b9, 0x607a, 0xdf0a, 0x4603, 0x617b, 0x697b, 0x4618, 0x371c, 0x46bd, 0xbc80, 0x4770,
        0xb480, 0xb085, 0xaf00, 0x6078, 0x6039, 0xdf0c, 0x4603, 0x60fb, 0x68fb, 0x4618, 0x3714, 0x46bd, 0xbc80, 0x4770,
        0xb480, 0xb085, 0xaf00, 0x6078, 0x2300, 0x60fb, 0xe002, 0x68fb, 0x3301, 0x60fb, 0x68fb, 0x687a, 0x4413, 0x781b,
        0x2b00, 0xd1f6, 0x68fb, 0x4618, 0x3714, 0x46bd, 0xbc80, 0x4770, 0xb580, 0xb084, 0xaf00, 0x6078, 0x6878, 0xf7ff,
        0xffe3, 0x60f8, 0x68fa, 0x6879, 0x2001, 0xf7ff, 0xff6b, 0x4603, 0x4618, 0x3710, 0x46bd, 0xbd80, 0xb580, 0xb086,
        0xaf00, 0x6078, 0x6039, 0x6838, 0xf7ff, 0xffd0, 0x60f8, 0x2300, 0x617b, 0xe018, 0x2300, 0x613b, 0xe00e, 0x697b,
        0x687a, 0x4413, 0x781a, 0x693b, 0x6839, 0x440b, 0x781b, 0x429a, 0xd101, 0x697b, 0xe010, 0x693b, 0x3301, 0x613b,
        0x693a, 0x68fb, 0x429a, 0xdbec, 0x697b, 0x3301, 0x617b, 0x697b, 0x687a, 0x4413, 0x781b, 0x2b00, 0xd1e0, 0x697b,
        0x4618, 0x3718, 0x46bd, 0xbd80, 0xb580, 0xb086, 0xaf00, 0x6078, 0x6039, 0x6838, 0xf7ff, 0xffa0, 0x60b8, 0x2300,
        0x617b, 0xe022, 0x2300, 0x74fb, 0x2300, 0x60fb, 0xe00e, 0x697b, 0x687a, 0x4413, 0x781a, 0x68fb, 0x6839, 0x440b,
        0x781b, 0x429a, 0xd101, 0x2301, 0x74fb, 0x68fb, 0x3301, 0x60fb, 0x68fa, 0x68bb, 0x429a, 0xdbec, 0x7cfb, 0xf083,
        0x0301, 0xb2db, 0x2b00, 0xd001, 0x697b, 0xe009, 0x697b, 0x3301, 0x617b, 0x697b, 0x687a, 0x4413, 0x781b, 0x2b00,
        0xd1d6, 0x697b, 0x4618, 0x3718, 0x46bd, 0xbd80, 0xb580, 0xb084, 0xaf00, 0x6078, 0x6039, 0x687b, 0x2b00, 0xd003,
        0x4b25, 0x447b, 0x687a, 0x601a, 0x4b24, 0x447b, 0x681b, 0x2b00, 0xd005, 0x4b23, 0x447b, 0x681b, 0x781b, 0x2b00,
        0xd101, 0x2300, 0xe035, 0x4b20, 0x447b, 0x681a, 0x4b1f, 0x447b, 0x601a, 0x4b1f, 0x447b, 0x681b, 0x6839, 0x4618,
        0xf7ff, 0xff70, 0x4602, 0x4b1c, 0x447b, 0x681b, 0x441a, 0x4b1b, 0x447b, 0x601a, 0x4b1a, 0x447b, 0x681b, 0x6839,
        0x4618, 0xf7ff, 0xff91, 0x60b8, 0x2300, 0x60fb, 0xe00e, 0x4b16, 0x447b, 0x681b, 0x2200, 0x701a, 0x4b14, 0x447b,
        0x681b, 0x1c5a, 0x4b13, 0x447b, 0x601a, 0x68fb, 0x3301, 0x60fb, 0x68fa, 0x68bb, 0x429a, 0xdbec, 0x4b0f, 0x447b,
        0x681b, 0x4618, 0x3710, 0x46bd, 0xbd80, 0xbf00, 0x1546, 0x0000, 0x153e, 0x0000, 0x1534, 0x0000, 0x1524, 0x0000,
        0x1522, 0x0000, 0x1518, 0x0000, 0x1508, 0x0000, 0x1500, 0x0000, 0x14fa, 0x0000, 0x14e4, 0x0000, 0x14da, 0x0000,
        0x14d2, 0x0000, 0x14c2, 0x0000, 0xb480, 0xb085, 0xaf00, 0x6078, 0x6039, 0x2300, 0x60fb, 0xbf00, 0x68fb, 0x687a,
        0x4413, 0x781b, 0x2b00, 0xd01e, 0xe017, 0x68fb, 0x687a, 0x4413, 0x781a, 0x68fb, 0x6839, 0x440b, 0x781b, 0x429a,
        0xd102, 0x68fb, 0x3301, 0x60fb, 0x68fb, 0x687a, 0x4413, 0x781b, 0x4619, 0x68fb, 0x683a, 0x4413, 0x781b, 0x1acb,
        0xe006, 0x68fb, 0x683a, 0x4413, 0x781b, 0x2b00, 0xd1e1, 0x2300, 0x4618, 0x3714, 0x46bd, 0xbc80, 0x4770, 0xb480,
        0xb089, 0xaf00, 0x60f8, 0x60b9, 0x607a, 0x68fb, 0x2b00, 0xd104, 0x68bb, 0x2230, 0x701a, 0x68bb, 0xe03a, 0x2300,
        0x61fb, 0x68fb, 0x61bb, 0xe007, 0x69fb, 0x3301, 0x61fb, 0x69ba, 0x687b, 0xfb92, 0xf3f3, 0x61bb, 0x69bb, 0x2b00,
        0xd1f4, 0xe025, 0x68fb, 0x687a, 0xfb93, 0xf2f2, 0x6879, 0xfb01, 0xf202, 0x1a9b, 0x75fb, 0x7dfb, 0x2b09, 0xd909,
        0x69fb, 0x3b01, 0x68ba, 0x4413, 0x7dfa, 0xf1c2, 0x024b, 0xb2d2, 0x701a, 0xe007, 0x69fb, 0x3b01, 0x68ba, 0x4413,
        0x7dfa, 0x3230, 0xb2d2, 0x701a, 0x68fa, 0x687b, 0xfb92, 0xf3f3, 0x60fb, 0x69fb, 0x3b01, 0x61fb, 0x68fb, 0x2b00,
        0xd1d6, 0x68bb, 0x4618, 0x3724, 0x46bd, 0xbc80, 0x4770, 0xbf00, 0x0020, 0x0000, 0x3e20, 0x0020, 0x000a, 0x0000,
        0x0020, 0x0000, 0x6568, 0x706c, 0x0000, 0x0000, 0x0068, 0x0000, 0x6554, 0x706d, 0x726f, 0x7261, 0x6c69, 0x2079,
        0x7661, 0x6961, 0x616c, 0x6c62, 0x2065, 0x6f63, 0x6d6d, 0x6e61, 0x7364, 0x0a3a, 0x2009, 0x2820, 0x2968, 0x6c65,
        0x2070, 0x202d, 0x7270, 0x6e69, 0x7374, 0x7420, 0x6968, 0x2073, 0x6568, 0x706c, 0x7320, 0x7263, 0x6565, 0x0a6e,
        0x2009, 0x2020, 0x7228, 0x7529, 0x206e, 0x202d, 0x7572, 0x736e, 0x7320, 0x6570, 0x6963, 0x6966, 0x6465, 0x6120,
        0x7070, 0x202c, 0x6669, 0x6e20, 0x206f, 0x7261, 0x7567, 0x656d, 0x746e, 0x6920, 0x2073, 0x7270, 0x766f, 0x6469,
        0x6465, 0x7220, 0x6e75, 0x2073, 0x7270, 0x636f, 0x0a32, 0x2009, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x7328,
        0x6174, 0x646e, 0x7261, 0x2064, 0x6e69, 0x7570, 0x2074, 0x6574, 0x7473, 0x2e29, 0x5020, 0x6f72, 0x3163, 0x6920,
        0x2073, 0x6c61, 0x6572, 0x6461, 0x2079, 0x7572, 0x6e6e, 0x6e69, 0x2067, 0x6428, 0x6f69, 0x6564, 0x0a29, 0x2009,
        0x2820, 0x296b, 0x6c69, 0x206c, 0x202d, 0x696b, 0x6c6c, 0x2073, 0x7270, 0x636f, 0x2031, 0x6428, 0x6f69, 0x6564,
        0x0a29, 0x2809, 0x296d, 0x726f, 0x6963, 0x206b, 0x202d, 0x7270, 0x6e69, 0x7374, 0x6120, 0x6320, 0x6c6f, 0x726f,
        0x7566, 0x206c, 0x656d, 0x7373, 0x6761, 0x0a65, 0x2009, 0x2020, 0x2020, 0x2020, 0x2d2d, 0x2d2d, 0x0a2d, 0x2009,
        0x2020, 0x2020, 0x6c20, 0x2073, 0x202d, 0x696c, 0x7473, 0x2073, 0x7563, 0x7272, 0x6e65, 0x2074, 0x6964, 0x6572,
        0x7463, 0x726f, 0x0a79, 0x2009, 0x2020, 0x6b6d, 0x6964, 0x2072, 0x202d, 0x7263, 0x6165, 0x6574, 0x2073, 0x2061,
        0x6964, 0x6572, 0x7463, 0x726f, 0x2079, 0x6e75, 0x6564, 0x2072, 0x7073, 0x6365, 0x6669, 0x6569, 0x2064, 0x6170,
        0x6874, 0x090a, 0x2020, 0x7420, 0x756f, 0x6863, 0x2d20, 0x6320, 0x6572, 0x7461, 0x7365, 0x6120, 0x6620, 0x6c69,
        0x2065, 0x6e75, 0x6564, 0x2072, 0x7073, 0x6365, 0x6669, 0x6569, 0x2064, 0x6170, 0x6874, 0x090a, 0x2020, 0x2020,
        0x6320, 0x7461, 0x2d20, 0x7220, 0x6165, 0x7364, 0x6620, 0x6c69, 0x2065, 0x6f63, 0x746e, 0x6e65, 0x7374, 0x090a,
        0x2020, 0x6528, 0x6329, 0x6f68, 0x2d20, 0x7720, 0x6972, 0x6574, 0x2073, 0x6f74, 0x7320, 0x6174, 0x646e, 0x7261,
        0x2064, 0x6e69, 0x7570, 0x2074, 0x726f, 0x7220, 0x6465, 0x7269, 0x6365, 0x7374, 0x7420, 0x206f, 0x2061, 0x6966,
        0x656c, 0x090a, 0x7220, 0x7761, 0x6365, 0x6f68, 0x2d20, 0x7720, 0x6972, 0x6574, 0x2073, 0x6f63, 0x766e, 0x7265,
        0x6574, 0x2064, 0x6568, 0x6178, 0x6564, 0x6963, 0x616d, 0x206c, 0x7962, 0x6574, 0x2073, 0x6f74, 0x7320, 0x6570,
        0x6963, 0x6966, 0x6465, 0x6620, 0x6c69, 0x2065, 0x6d28, 0x7861, 0x3120, 0x3832, 0x6220, 0x7479, 0x7365, 0x0a29,
        0x000a, 0x0000, 0x7572, 0x006e, 0x0072, 0x0000, 0x7845, 0x6365, 0x7475, 0x6261, 0x656c, 0x6e20, 0x746f, 0x6620,
        0x756f, 0x646e, 0x0a2e, 0x0000, 0x1b0a, 0x395b, 0x3b36, 0x3034, 0x5b6d, 0x4150, 0x4554, 0x2052, 0x4441, 0x4d41,
        0x5356, 0x1b5d, 0x305b, 0x206d, 0x6843, 0x6c69, 0x2064, 0x7270, 0x636f, 0x7365, 0x2073, 0x0000, 0x7865, 0x7469,
        0x6465, 0x7720, 0x7469, 0x2068, 0x6f63, 0x6564, 0x203a, 0x0000, 0x696b, 0x6c6c, 0x0000, 0x0000, 0x006b, 0x0000,
        0x2f4e, 0x0061, 0x6f6d, 0x6372, 0x6b69, 0x0000, 0x006d, 0x0000, 0x5b1b, 0x3539, 0x343b, 0x6d30, 0x654d, 0x6e69,
        0x2065, 0x6562, 0x696c, 0x6265, 0x6574, 0x4f20, 0x676c, 0x2061, 0x7369, 0x2074, 0x6964, 0x2065, 0x6373, 0xf668,
        0x736e, 0x6574, 0x4620, 0x6172, 0x2075, 0x7561, 0x2066, 0x6564, 0x2072, 0x6557, 0x746c, 0x1b0a, 0x305b, 0x006d,
        0x6365, 0x6f68, 0x0000, 0x0000, 0x0065, 0x0000, 0x003e, 0x0000, 0x0000, 0x0000, 0x6f4e, 0x7320, 0x6375, 0x2068,
        0x6966, 0x656c, 0x0a2e, 0x0000, 0x736c, 0x0000, 0x6f4e, 0x7320, 0x6375, 0x2068, 0x6966, 0x656c, 0x002e, 0x0000,
        0x6463, 0x0000, 0x7770, 0x0064, 0x0020, 0x0000
};

void PATER_ADAMVS(int argc, char *argv[]) {
        signal(SIGINT, PATER_ADAMVS_SIGINT);
        printf("\n\x1b[96;40mPATER ADAMVS QUI EST IN PARADISO VOLVPTATIS SALVTAT SEQUENTES PROCESS FILIOS\x1b[0m\n");

        [[maybe_unused]] const int proc1_pid = spawn(proc1, nullptr, nullptr, nullptr, nullptr);

        while (1) {
                char *const ls_argv[] = {"gsh"};
                spawn((void *) raw_ls + 1, nullptr, nullptr, ls_argv, nullptr);
                int code;
                const int returned_pid = wait(&code);

                printf(
                        "\n\x1b[96;40m[PATER ADAMVS]\x1b[0m Child raw-bytes shell process %i exited with code %i. Running again.\n",
                        returned_pid, code
                );
        }
#if 0
        while (1) {
                printf(" > ");
                char buffer[256];
                if (fgets(buffer, sizeof(buffer), stdin) == nullptr) {
                        continue;
                }
                buffer[strcspn(buffer, "\n")] = '\0';
                const char *cmd = kstrtok(buffer, " ");

                if (strcmp(cmd, "help") == 0 || strcmp(cmd, "h") == 0) {
                        printf("Temporarily available commands:\n"
                                "\t  (h)elp - prints this help screen\n"
                                "\t   (r)un - runs specified app, if no argument is provided runs proc2\n"
                                "\t           (standard input test). Proc1 is already running (diode)\n"
                                "\t  (k)ill - kills proc1 (diode)\n"
                                "\t(m)orcik - prints a colorful message\n"
                                "\t     rls - runs raw-bytes written ls command (mock for userspace program)\n\t---\n"
                                "\t      ls - lists current directory\n"
                                "\t   mkdir - creates a directory under specified path\n"
                                "\t   touch - creates a file under specified path\n"
                                "\t     cat - reads file contents\n"
                                "\t  (e)cho - writes to standard input or redirects to a file\n"
                                "\t rawecho - writes converted hexadecimal bytes to specified file (max 128 bytes)\n\n");
                }
                else if (strcmp(cmd, "run") == 0 || strcmp(cmd, "r") == 0) {
                        const char *path = kstrtok(nullptr, " ");
                        printf("\x1b[96;40m[PATER ADAMVS]\x1b[0m I will be waiting until my child is dead . . .\n");

                        int fd = open(path, O_BINARY);
                        if (fd > 0) {
                                uint16_t raw_bytes_app[128];
                                read(fd, raw_bytes_app, 128);
                                spawn((void *) raw_bytes_app + 1, nullptr, nullptr, nullptr, nullptr);
                        }
                        else {
                                spawn((void *) &proc2_main, nullptr, nullptr, nullptr, nullptr);
                        }

                        int code;
                        const int returned_pid = wait(&code);

                        printf("\n\x1b[96;40m[PATER ADAMVS]\x1b[0m Child process %i exited with code %i.\n",
                               returned_pid, code);
                }
                else if (strcmp(cmd, "kill") == 0 || strcmp(cmd, "k") == 0) {
                        printf("You are willing to kill the process. Choose (1) SIGTERM or (2) SIGKILL: ");

                        char line[80];
                        fgets(line, sizeof(line), stdin);
                        const int choice = strtol(line, nullptr, 10);


                        if (choice == 1) {
                                kill(proc1_pid, SIGTERM);
                        }
                        else if (choice == 2) {
                                kill(proc1_pid, SIGKILL);
                        }
                        else {
                                printf("This is not a valid signal. I won't kill the process.\n");
                        }
                }
                else if (strcmp(cmd, "morcik") == 0 || strcmp(cmd, "m") == 0) {
                        printf("\x1b[95;40mMeine beliebte Olga ist die sch\xf6nste Frau auf der Welt\n\x1b[0m");
                }
                else if (strcmp(cmd, "rls") == 0) {
                        char const *path_tok = kstrtok(nullptr, " ");
                        const char *path = path_tok ? path_tok : "";

                        char *const ls_argv[] = {"ls", path, nullptr};
                        spawn((void *) raw_ls + 1, nullptr, nullptr, ls_argv, nullptr);
                        int code;
                        const int returned_pid = wait(&code);

                        printf("\n\x1b[96;40m[PATER ADAMVS]\x1b[0m Child raw-bytes process %i exited with code %i.\n",
                               returned_pid, code);
                }
                else if (strcmp(cmd, "echo") == 0 || strcmp(cmd, "e") == 0) {
                        const char *text = kstrtok(nullptr, ">");
                        const char *path = kstrtok(nullptr, "");
                        if (!text) {
                                continue;
                        }

                        if (!path) {
                                printf("%s\n", text);
                                continue;
                        }

                        int fd = open(path, O_WRONLY);
                        if (fd < 0) {
                                printf("No such file.\n");
                                continue;
                        }

                        write(fd, text, strlen(text) + 1); // with EOF

                        close(fd);
                }
                else if (strcmp(cmd, "rawecho") == 0) {
                        const char *text = kstrtok(nullptr, ">");
                        const char *path = kstrtok(nullptr, "");
                        if (!text || !path) {
                                continue;
                        }

                        int fd = open(path, O_BINARY);
                        if (fd < 0) {
                                printf("No such file.\n");
                                continue;
                        }

                        uint8_t bytes[128] = {};
                        memset(bytes, 0, 128);
                        size_t index = 0;

                        const char *ptr = text;
                        char *endptr;
                        while (*ptr) {
                                while (*ptr == ' ') {
                                        ptr += 1;
                                }

                                if (*ptr == '\0') {
                                        break;
                                }

                                long value = strtol(ptr, &endptr, 16);

                                if (ptr == endptr) {
                                        // No valid number found
                                        break;
                                }

                                // Clamp to uint8_t range
                                if (value < 0 || value > 0xFF) {
                                        printf("Warning: value out of range (0x%lX)\n", value);
                                        break;
                                }

                                bytes[index++] = (uint8_t) value;

                                // Move pointer to next potential number
                                ptr = endptr;
                        }

                        write(fd, bytes, index);

                        close(fd);
                }
                else if (strcmp(cmd, "ls") == 0) {
                        const char *path_tok = kstrtok(nullptr, " ");
                        const char *path = path_tok == nullptr ? "" : path_tok;
                        const int dirfd = open(path, O_DIRECTORY | O_RDONLY);

                        if (dirfd < 0) {
                                printf("No such file.");
                                continue;
                        }

                        struct DirectoryEntry dentry;
                        while (readdir(dirfd, &dentry) == 1) {
                                printf("%c %s\n", dentry.file_type, dentry.name);
                        }

                        lseek(dirfd, 0, SEEK_SET);
                }
                else if (strcmp(cmd, "mkdir") == 0) {
                        const char *path = kstrtok(nullptr, " ");
                        if (!path) {
                                continue;
                        }

                        int dirfd = open(path, O_DIRECTORY | O_CREAT);
                        close(dirfd);
                }
                else if (strcmp(cmd, "touch") == 0) {
                        const char *path = kstrtok(nullptr, " ");
                        if (!path) {
                                continue;
                        }

                        int fd = open(path, O_CREAT);
                        close(fd);
                }
                else if (strcmp(cmd, "cat") == 0) {
                        const char *path = kstrtok(nullptr, " ");
                        if (!path) {
                                continue;
                        }

                        int fd = open(path, O_RDONLY);
                        if (fd < 0) {
                                printf("No such file.\n");
                                continue;
                        }

                        char file_contents[128] = {};
                        read(fd, &file_contents, 128);
                        printf("File contents: %s\n", file_contents);
                        close(fd);
                }
                else if (strcmp(cmd, "cd") == 0) {
                        const char *path = kstrtok(nullptr, " ");

                        const int code = chdir(path);
                        if (code == -1) {
                                printf("No such file.\n");
                        }
                }
                else if (strcmp(cmd, "pwd") == 0) {
                        char buf[64];
                        char *ptr = buf;
                        char *ret = getcwd(ptr, 64);

                        printf("%s\n", ret);
                }
                else {
                        printf("\x1b[96;40m[PATER ADAMVS]\x1b[0m command unknown, type (h)elp to get help.\n");
                }
        }
#endif
}

int main(void) {
        reset_subsys();
        setup_internal_clk();
        uart_init();
        uart_clr_screen();
        vga_init(8, 9, 2);

        init_pin_output(25);
        init_pin_output(11);

        void *msp;
        __asm__("mrs    %0, msp" : "=r"(msp));
        scheduler_init(msp);


        struct Dentry *root = ramfs_mount(nullptr, nullptr, nullptr, 0);
        constexpr size_t root_dirs_count = 7;
        const char *root_dirs[root_dirs_count] = {"bin", "boot", "dev", "etc", "home", "proc", "sbin"};
        for (size_t i = 0; i < root_dirs_count; ++i) {
                struct Dentry file = {
                        .name = root_dirs[i],
                };
                root->inode->i_op->create(root->inode, &file, S_IFDIR | 0666);
        }

        struct Dentry dev_dentry = {.name = "dev"};
        struct Dentry *dev = root->inode->i_op->lookup(root->inode, &dev_dentry, 0);
        struct Dentry tty_dentry = {
                .name = "tty0",
        };
        dev->inode->i_op->create(dev->inode, &tty_dentry, S_IFCHR | 0666);
        struct Dentry *tty = dev->inode->i_op->lookup(dev->inode, &tty_dentry, 0);

        init_tty();
        setup_tty_chrfile(tty->inode);
        init_keyboard(14);

        //TODO: REPLACE WITH PRINTK
        // printf("\x1b[40;47mWelcome in the kernel.\x1b[0m\n"
        //         "\x1b[92;40mSwitching to init process (temporary shell).\x1b[0m\n");
#if 0
        // create root directory and two test files

        struct Dentry file1 = {
                .name = "test.txt",
        };
        struct Dentry file2 = {
                .name = "a.out",
        };
        root_inode->i_op->create(root_inode, &file1, 0666);
        root_inode->i_op->create(root_inode, &file2, 0777);


        // usage read first file in directory
        struct File parent_handler = {
                .f_inode = root_inode,
                .f_op = root_inode->i_fop,
        };

        char buf[512];
        parent_handler.f_op->read(&parent_handler, &buf, 512, 0);
        size_t first_size = ((struct DirectoryEntry *) (&buf))->rec_len;
        struct DirectoryEntry *first_dentry = kmalloc(first_size);
        for (size_t i = 0; i < first_size; ++i) {
                *((char *) (first_dentry) + i) = buf[i];
        }

        auto first_inode = (struct VFS_Inode *) root->sb->inode_table[first_dentry->inode_index];
        printf("Mode: %o UID: %i GID: %i <time> %ldB %s\n", first_inode->i_mode,
               first_inode->i_uid,
               first_inode->i_gid, first_inode->i_size,
               first_dentry->name);

        // write to first file
        printf("\nWriting to file . . .\n\n");
        struct File first_file = {
                .f_inode = first_inode,
                .f_pos = 0,
        };
        char message[] = "Hello World!";
        first_inode->i_fop->write(&first_file, &message, sizeof(message), 0);

        char bytes_in_file[512];
        first_inode->i_fop->read(&first_file, &bytes_in_file, first_inode->i_size, 0);
        printf("New File Contents:\n\t%s\n", bytes_in_file);

        printf("New File Status:\nMode: %o UID: %i GID: %i <time> %ldB %s\n", first_inode->i_mode,
               first_inode->i_uid,
               first_inode->i_gid, first_inode->i_size,
               first_dentry->name);
#endif

        create_process_init((void (*)(void)) PATER_ADAMVS, root->inode);
        run_process_init();
        return 0;
}
